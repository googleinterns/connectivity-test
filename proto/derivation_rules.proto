// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto2";
package google.cloud.network.reachability;

import "proto/rules.proto";
import "proto/cloud_network_model.proto";

message DestinationAndGeneration {
  // The new route are generated in the following priority order:
  // - generated by a series of corresponding Python functions
  // - copied from the original route, and merged from the route_template
  // - copied from the original route
  //
  // The naming convention to access the Python functions are:
  // - all .py files under src/derivation_rules are parsed and only functions are extracted.
  // - the functions should not collide in names
  // - the functions are invoked by name, in the following order:
  //    -- <destination_name>_generator
  //    -- <rule_name>_<destination name>_generator
  //        the rule_name here is the optional name of the matching RouteDerivationRule
  //
  // - each function receives three parameters: route, context, and model
  // - each function modifies the input route, and returns the same route
  // - the context is a destination-specific protobuf defined below as "DestinationContext"
  //
  // A limited programming ability is provided to specify some predicates based on
  // the Route proto. In each field of the Route proto where the type is "string", use
  // triple grave accent (```) in the beginning to start a Python lambda function
  // body. This lambda has the following implicit parameters:
  // - *route* the route being generated
  // - *root_route* the root route
  // - *region* the region to install the route, for dynamic and peering_dynamic routes.
  //
  // And the return value is converted to a string. If exception are raised, skip this field
  // Example:
  //    route_template {
  //      region: "```root_route.region"
  //    }
  optional Route route_template = 4;

  // The destinations have fixed builtin semantics in destination selection and actions.
  //   - VPC_PEERS:                  all active peering VPC networks
  //
  //   - VPC_PEERS_CUSTOM_ROUTING:   all active peering VPC networks that import custom routes from the route's network,
  //                                 and simultaneously, the route's network export custom routes to them.
  //
  //   - REGIONS_OF_VPC_PEERS_CUSTOM_ROUTING: all active peering VPC networks that import custom routes from the route's network,
  //                                 and simultaneously, the route's network export custom routes to them. The route is
  //                                 exported to all regions that the network has presence.
  //
  //   - BGP_PEERS:                  all networks that hold one or more *live* BGP session with the current network, and
  //                                 the involved VPN tunnels in current network enable subnet advertising
  //
  //   - OTHER_REGIONS_WHEN_GLOBAL_ROUTING:   all regions other than the route's region, when the current network enables
  //                                          global routing
  //
  // Some fixed actions are bound to each destination as part of the semantics of the destination.
  // These semantics are written as rules
  // For all:
  // - set name, id, url
  // - update the *instance_filter.network*
  //
  // For VPC peering:
  // - update *next_hop_peering*
  // - delete other next hops
  // - change the route type to the corresponding peering type
  //
  // For BGP peering:
  // - fill the field "region"
  // - update *next_hop_tunnel*
  // - delete other next hops
  enum Destination {
    // VPC_PEERS works as a short cut for VPC_PEERS_NO_CUSTOM_ROUTING and VPC_PEERS_CUSTOM_ROUTING. It is first internally
    // translated to VPC_PEERS_NO_CUSTOM_ROUTING and VPC_PEERS_CUSTOM_ROUTING, before any derivation process
    VPC_PEERS = 0;
    VPC_PEERS_CUSTOM_ROUTING = 2;
    REGIONS_OF_VPC_PEERS_CUSTOM_ROUTING = 1;
    BGP_PEERS = 3;
    OTHER_REGIONS_WHEN_GLOBAL_ROUTING = 4;
  }

  required Destination destination = 6;

  message DestinationContext {
    required string network = 1;
    // for regional routes
    optional string region = 2;
    // the vpc peering, or the vpn tunnel used in BGP peering
    optional string peer_info = 3;
  }
}

message RouteDerivationRule {
  optional string name = 1;

  // The filter of a route to be applied for this rule.
  // Recommended usage: set `type` or `region` to pick the routes for a single type or region
  // The matching is exact match for all present fields.
  // Can specify many filters and if any filter is an exact match, this whole rule is a match
  //
  // A limited programming ability is provided to specify some predicates based on
  // the Route proto. In each field of the Route proto where the type is "string", use
  // triple grave accent (```) in the beginning to start a Python boolean lambda function
  // body. This lambda has the following implicit parameters:
  // - *route* the route being matched
  // And the return value is converted to a boolean. If exception are raised, consider it
  // as a non-match
  // Example:
  //    filters {
  //      region: "us-west1"
  //    }
  //    and
  //    filters {
  //      region: "```route.region == 'us-west1'"
  //    }
  // Both rules match routes that in region us-west1.
  repeated Route filters = 2;

  // A limited programming ability is provided to specify some predicates based on
  // the Route proto. The predicate is expressed by a Python boolean lambda function body.
  // This lambda has the following implicit parameters:
  // - *route* the route being matched
  //
  // And the return value is converted to a boolean. If exception are raised, consider it
  // as a non-match
  // Example:
  // {
  //   lambda_filters: "route.instance_filter.attributes[0].tag"
  // }
  // This rule matches routes that are assigned with tags.
  repeated string lambda_filters = 3;

  repeated DestinationAndGeneration destinations = 6;
}

message RuleOrder {
  repeated string file_names = 1;
}

message EnabledGenerators {
  repeated string file_names = 1;
}

message RuleSet {
  // Rules are matched in order. First wins
  repeated RouteDerivationRule rules = 10;
}