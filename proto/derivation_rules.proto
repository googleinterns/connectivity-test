// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto2";
package google.cloud.network.reachability;

import "proto/rules.proto";
import "proto/cloud_network_model.proto";

message DestinationAndGeneration {
  // The new route are generated in the following priority order:
  // - generated by a series of corresponding Python functions
  // - copied from the original route, and merged from the route_template
  // - copied from the original route
  //
  // The naming convention to access the Python functions are:
  // - all .py files under src/derivation_rules are parsed and only functions are extracted.
  // - the functions should not collide in names
  // - the functions are invoked by name, in the following order:
  //    -- <destination_name>_generator
  //    -- <rule_name>_<destination name>_generator
  //        the rule_name here is the optional name of the matching RouteDerivationRule
  //
  // - each function receives three parameters: route, context, and model
  // - each function modifies the input route, and returns the same route
  // - the context is a destination-specific protobuf defined below as "DestinationContext"
  //
  // A limited programming ability is provided to specify some predicates based on
  // the Route proto. In each field of the Route proto where the type is "string", use
  // triple grave accent (```) in the beginning to start a Python lambda function
  // body. This lambda has the following implicit parameters:
  // - *route* the route being generated
  // - *root_route* the root route
  // - *region* the region to install the route, for dynamic and peering_dynamic routes.
  //
  // And the return value is converted to a string. If exception are raised, skip this field
  // Example:
  //    route_template {
  //      region: "```root_route.region"
  //    }
  optional Route route_template = 4;

  // The destinations have fixed builtin semantics in destination selection and actions.
  //    - VPC_Peers:                   all active peering VPC networks
  //
  //    - VPC_Peers_CustomRouting:     all active peering VPC networks that import custom routes from the route's network,
  //                                   and simultaneously, the route's network export custom routes to them
  //
  //    - BGP_Peers_GlobalRouting:     all networks that establish a *live* BGP session to the route's network, and they
  //                                   are in global routing mode
  //
  //    - BGP_Peers_RegionalRouting:   all networks that establish a *live* BGP session to the route's network, and they
  //                                   are in regional routing mode
  //
  // Some fixed actions are bound to each destination as part of the semantics of the destination.
  // These semantics are written as rules
  // For all:
  // - update the *instance_filter.network*
  //
  // For VPC peering:
  // - update *next_hop_peering*
  // - delete other next hops
  // - change the route type to the corresponding peering type
  //
  // For BGP peering:
  // - fill the field "region"
  // - update *next_hop_tunnel*
  // - delete other next hops
  enum Destination {
    VPC_Peers = 0;  // This works as a short cut for VPC_Peers_NoCustomRouting and VPC_Peers_CustomRouting.
    // VPC_Peers is internally first translated to VPC_Peers_NoCustomRouting and VPC_Peers_CustomRouting, before any
    // derivation process
    VPC_Peers_NoCustomRouting = 1; // You can not specify two destinations with VPC_Peers and VPC_Peers_NoCustomRouting
    VPC_Peers_CustomRouting = 2;    // You can not specify two destinations with VPC_Peers and VPC_Peers_CustomRouting
    BGP_Peers_GlobalRouting = 3;
    BGP_Peers_RegionalRouting = 4;
  }

  required Destination destination = 6;

  message DestinationContext {
    required string network = 1;
    // for regional routes
    optional string region = 2;
    // the vpc peering, or the vpn tunnel used in BGP peering
    optional string peer_info = 3;
  }
}

message RouteDerivationRule {
  optional string name = 1;

  // The filter of a route to be applied for this rule.
  // Recommended usage: set `type` or `region` to pick the routes for a single type or region
  // The matching is exact match for all present fields.
  // Can specify many filters and if any filter is an exact match, this whole rule is a match
  //
  // A limited programming ability is provided to specify some predicates based on
  // the Route proto. In each field of the Route proto where the type is "string", use
  // triple grave accent (```) in the beginning to start a Python boolean lambda function
  // body. This lambda has the following implicit parameters:
  // - *route* the route being matched
  // And the return value is converted to a boolean. If exception are raised, consider it
  // as a non-match
  // Example:
  //    filters {
  //      region: "us-west1"
  //    }
  //    and
  //    filters {
  //      region: "```route.region == 'us-west1'"
  //    }
  // Both rules match routes that in region us-west1.
  repeated Route filters = 2;

  // A limited programming ability is provided to specify some predicates based on
  // the Route proto. The predicate is expressed by a Python boolean lambda function body.
  // This lambda has the following implicit parameters:
  // - *route* the route being matched
  //
  // And the return value is converted to a boolean. If exception are raised, consider it
  // as a non-match
  // Example:
  // {
  //   lambda_filters: "route.instance_filter.attributes[0].tag"
  // }
  // This rule matches routes that are assigned with tags.
  repeated string lambda_filters = 3;

  repeated DestinationAndGeneration destinations = 6;
}

message RuleOrder {
  repeated string file_names = 1;
}

message RuleSet {
  // Rules are matched in order. First wins
  repeated RouteDerivationRule rules = 10;
}